<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>왼트_LeftTry</title>
    <style>
        @font-face {
            font-family: 'NeoDunggeunmoPro';
            src: url('Data/font/NeoDunggeunmoPro-Regular.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        body {
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: 'NeoDunggeunmoPro', sans-serif;
        }
        #game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #game-container {
            display: inline-block;
            background-color: #080808;
            padding: calc(10px * 1.25);
            position: relative;
        }
        .grid {
            display: grid;
            gap: calc(2px * 1.25);
        }
        .tile {
            width: calc(40px * 1.25);
            height: calc(40px * 1.25);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: calc(16px * 1.25);
            color: #000;
            cursor: pointer;
            position: relative;
        }
        .tile img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            z-index: 1;
            pointer-events: none;
        }
        .empty { background-color: #293141; }
        .floor { background-color: #15181F; }
        .floor::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 0;
        }
        .green { background-color: #00FF00; }
        .yellow { background-color: #FFFF00; }
        .red { background-color: #FF0000; }
        .blue { background-color: #0000FF; }
        
        /* 추적 상태 시각화 */
        .tracking {
            border: 3px solid #ff6600 !important;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { border-color: #ff6600; }
            50% { border-color: #ffaa00; }
            100% { border-color: #ff6600; }
        }
        
        /* 공격 이펙트 */
        .attack-effect-near {
            position: absolute;
            background: radial-gradient(circle, rgba(255, 100, 0, 0.9), rgba(255, 0, 0, 0.5), transparent);
            border-radius: 50%;
            z-index: 1000;
            pointer-events: none;
            animation: explode 1.5s ease-out;
        }
        .attack-effect-far {
            position: absolute;
            background: linear-gradient(90deg, rgba(255, 0, 0, 0.9), rgba(255, 100, 0, 0.7), transparent);
            z-index: 1000;
            pointer-events: none;
            animation: laser 0.3s ease-out;
        }
        .attack-effect-blue-near {
            position: absolute;
            background: radial-gradient(circle, rgba(0, 100, 255, 0.9), rgba(0, 0, 255, 0.5), transparent);
            border-radius: 50%;
            z-index: 1000;
            pointer-events: none;
            animation: explode 1.5s ease-out;
        }
        .attack-effect-blue-far {
            position: absolute;
            background: linear-gradient(90deg, rgba(0, 0, 255, 0.9), rgba(0, 100, 255, 0.7), transparent);
            z-index: 1000;
            pointer-events: none;
            animation: laser 0.3s ease-out;
        }
        
        @keyframes explode {
            0% { transform: scale(0.5); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(2); opacity: 0; }
        }
        @keyframes laser {
            0% { opacity: 1; transform: scaleX(0); }
            50% { opacity: 1; transform: scaleX(1); }
            100% { opacity: 0; transform: scaleX(1); }
        }
        
        #stage-display {
            font-size: calc(18px * 1.25);
            text-align: center;
            margin-bottom: calc(10px * 1.25);
            color: #fff;
            font-family: 'NeoDunggeunmoPro', sans-serif;
        }
        #message {
            font-size: calc(20px * 1.25);
            text-align: center;
            margin-top: calc(10px * 1.25);
            color: #fff;
            font-family: 'NeoDunggeunmoPro', sans-serif;
        }
        #tooltip {
            font-size: calc(16px * 1.25);
            text-align: center;
            margin-top: calc(10px * 1.25);
            color: #ccc;
            max-width: calc(600px * 1.25);
            font-family: 'NeoDunggeunmoPro', sans-serif;
        }
        #tooltip p {
            margin: calc(5px * 1.25) 0;
        }
        #clear-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: calc(48px * 1.25);
            color: #fff;
            background-color: rgba(0, 0, 0, 0.7);
            padding: calc(20px * 1.25) calc(40px * 1.25);
            border-radius: calc(10px * 1.25);
            display: none;
            z-index: 1000;
            font-family: 'NeoDunggeunmoPro', sans-serif;
        }
        @keyframes fadeInOut {
            0% { opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }
        .fade-in-out {
            animation: fadeInOut 2s ease-in-out;
        }
        @keyframes attackEffect {
            0% { background-color: rgba(255, 0, 0, 0); }
            50% { background-color: rgba(255, 0, 0, 0.7); }
            100% { background-color: rgba(255, 0, 0, 0); }
        }
        .attack-effect {
            animation: attackEffect 0.5s ease-in-out;
        }
        #bgm {
            display: none;
        }
    </style>
</head>
<body>
    <div id="game-wrapper">
        <div id="game-container">
            <div id="stage-display"></div>
            <div id="grid" class="grid"></div>
            <div id="message"></div>
        </div>
        <div id="tooltip"></div>
    </div>
    <div id="clear-message">Clear!</div>
    <audio id="bgm" loop></audio>

    <script>
        // --- 배경음악 설정 ---
        const bgmUrl = 'Data/music/1. Baba Is You Theme.mp3';
        const bgm = document.getElementById('bgm');
        let bgmLoaded = false;
        if (bgmUrl) {
            bgm.src = bgmUrl;
            bgm.volume = 0.5;
            bgm.muted = false;
            bgm.onerror = () => console.warn('BGM 로드 실패:', bgmUrl, bgm.error);
            bgm.onloadeddata = () => {
                console.log('BGM 로드 성공:', bgmUrl);
                bgmLoaded = true;
            };
            bgm.oncanplay = () => console.log('BGM 재생 가능 상태');
            bgm.onplay = () => console.log('BGM 재생 중');
            bgm.onended = () => console.log('BGM 재생 종료');
        }

        // --- 타일 및 오브젝트 이미지 매핑 (기존 유지) ---
        const tileImages = {};
        const objectImages = {
            '1P_aT': 'Data/sprites/1P_aT.png',
            '1P_aB': 'Data/sprites/1P_aB.png',
            '1P_aL': 'Data/sprites/1P_aL.png',
            '1P_aR': 'Data/sprites/1P_aR.png',
            '1P_bT': 'Data/sprites/1P_bT.png',
            '1P_bB': 'Data/sprites/1P_bB.png',
            '1P_bL': 'Data/sprites/1P_bL.png',
            '1P_bR': 'Data/sprites/1P_bR.png',
            '1F': 'Data/sprites/1F.png',
            '1A_aT': 'Data/sprites/1A_at.png',
            '1A_aB': 'Data/sprites/1A_aB.png',
            '1A_aL': 'Data/sprites/1A_aL.png',
            '1A_aR': 'Data/sprites/1A_aR.png',
            '1A_bT': 'Data/sprites/1A_bT.png',
            '1A_bB': 'Data/sprites/1A_bB.png',
            '1A_bL': 'Data/sprites/1A_bL.png',
            '1A_bR': 'Data/sprites/1A_bR.png',
            '1B_aT': 'Data/sprites/1B_at.png',
            '1B_aB': 'Data/sprites/1B_aB.png',
            '1B_aL': 'Data/sprites/1B_aL.png',
            '1B_aR': 'Data/sprites/1B_aR.png',
            '1B_bT': 'Data/sprites/1B_bT.png',
            '1B_bB': 'Data/sprites/1B_bB.png',
            '1B_bL': 'Data/sprites/1B_bL.png',
            '1B_bR': 'Data/sprites/1B_bR.png',
            '1W': 'Data/sprites/1W.png',
            '1I': 'Data/sprites/1I.png',
            
            '2P_aT': 'Data/sprites/2P_aT.png',
            '2P_aB': 'Data/sprites/2P_aB.png',
            '2P_aL': 'Data/sprites/2P_aL.png',
            '2P_aR': 'Data/sprites/2P_aR.png',
            '2P_bT': 'Data/sprites/2P_bT.png',
            '2P_bB': 'Data/sprites/2P_bB.png',
            '2P_bL': 'Data/sprites/2P_bL.png',
            '2P_bR': 'Data/sprites/2P_bR.png',
            '2F': 'Data/sprites/2F.png',
            '2A_aT': 'Data/sprites/2A_at.png',
            '2A_aB': 'Data/sprites/2A_aB.png',
            '2A_aL': 'Data/sprites/2A_aL.png',
            '2A_aR': 'Data/sprites/2A_aR.png',
            '2A_bT': 'Data/sprites/2A_bT.png',
            '2A_bB': 'Data/sprites/2A_bB.png',
            '2A_bL': 'Data/sprites/2A_bL.png',
            '2A_bR': 'Data/sprites/2A_bR.png',
            '2B_aT': 'Data/sprites/2B_at.png',
            '2B_aB': 'Data/sprites/2B_aB.png',
            '2B_aL': 'Data/sprites/2B_aL.png',
            '2B_aR': 'Data/sprites/2B_aR.png',
            '2B_bT': 'Data/sprites/2B_bT.png',
            '2B_bB': 'Data/sprites/2B_bB.png',
            '2B_bL': 'Data/sprites/2B_bL.png',
            '2B_bR': 'Data/sprites/2B_bR.png',
            '2W': 'Data/sprites/2W.png',
            '2I': 'Data/sprites/2I.png',
            
            '3P_aT': 'Data/sprites/3P_aT.png',
            '3P_aB': 'Data/sprites/3P_aB.png',
            '3P_aL': 'Data/sprites/3P_aL.png',
            '3P_aR': 'Data/sprites/3P_aR.png',
            '3P_bT': 'Data/sprites/3P_bT.png',
            '3P_bB': 'Data/sprites/3P_bB.png',
            '3P_bL': 'Data/sprites/3P_bL.png',
            '3P_bR': 'Data/sprites/3P_bR.png',
            '3F': 'Data/sprites/3F.png',
            '3A_aT': 'Data/sprites/3A_at.png',
            '3A_aB': 'Data/sprites/3A_aB.png',
            '3A_aL': 'Data/sprites/3A_aL.png',
            '3A_aR': 'Data/sprites/3A_aR.png',
            '3A_bT': 'Data/sprites/3A_bT.png',
            '3A_bB': 'Data/sprites/3A_bB.png',
            '3A_bL': 'Data/sprites/3A_bL.png',
            '3A_bR': 'Data/sprites/3A_bR.png',
            '3B_aT': 'Data/sprites/3B_at.png',
            '3B_aB': 'Data/sprites/3B_aB.png',
            '3B_aL': 'Data/sprites/3B_aL.png',
            '3B_aR': 'Data/sprites/3B_aR.png',
            '3B_bT': 'Data/sprites/3B_bT.png',
            '3B_bB': 'Data/sprites/3B_bB.png',
            '3B_bL': 'Data/sprites/3B_bL.png',
            '3B_bR': 'Data/sprites/3B_bR.png',
            '3W': 'Data/sprites/3W.png',
            '3I': 'Data/sprites/3I.png',
            
            '4A_aT': 'Data/sprites/4A_at.png',
            '4A_aB': 'Data/sprites/4A_aB.png',
            '4A_aL': 'Data/sprites/4A_aL.png',
            '4A_aR': 'Data/sprites/4A_aR.png',
            '4A_bT': 'Data/sprites/4A_bT.png',
            '4A_bB': 'Data/sprites/4A_bB.png',
            '4A_bL': 'Data/sprites/4A_bL.png',
            '4A_bR': 'Data/sprites/4A_bR.png',
            '4B_aT': 'Data/sprites/4B_at.png',
            '4B_aB': 'Data/sprites/4B_aB.png',
            '4B_aL': 'Data/sprites/4B_aL.png',
            '4B_aR': 'Data/sprites/4B_aR.png',
            '4B_bT': 'Data/sprites/4B_bT.png',
            '4B_bB': 'Data/sprites/4B_bB.png',
            '4B_bL': 'Data/sprites/4B_bL.png',
            '4B_bR': 'Data/sprites/4B_bR.png',
            '4W': 'Data/sprites/4W.png',
            '4I': 'Data/sprites/4I.png',
        };

        // --- 스테이지 데이터 (기존 유지) ---
        const stages = [
            {
                map: [
                    ['--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--'],
                    ['--', '--', '--', '1P', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--'],
                    ['--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--'],
                    ['--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--'],
                    ['--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--'],
                    ['--', '--', '--', '00', '--', '2I', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--'],
                    ['--', '00', '--', '3A', '00', '--', '--', '--', '--', '00', '00', '--', '--', '--', '--', '3B', '--', '--', '--', '--', '--'],
                    ['--', '--', '--', '--', '00', '--', '--', '--', '--', '00', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--'],
                    ['--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--'],
                    ['--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--'],
                    ['--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--'],
                    ['--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--'],
                    ['--', '--', '--', '--', '--', '--', '--', '--', '--', '--', '2F', '--', '--', '--', '--', '--', '--', '--', '--', '--', '--']
                ],
                tooltip: [
                    'AI 테스트 스테이지 - 빨간색 근거리(3A)와 원거리(3B) 공격 물체가 추적합니다.',
                    '3A는 A* 경로탐색으로 접근하고, 3B는 2턴마다 원거리 공격합니다.',
                    '추적 중인 AI는 주황색 테두리로 표시됩니다.'
                ]
            },
            {
                map: [
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00'],
                    ['00', '1P', '--', '--', '--', '--', '--', '--', '2F', '00'],
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00']
                ],
                tooltip: [
                    '초록색 플레이어가 노란색 도착점에 닿으면 레벨이 클리어 됩니다.',
                    'W, A, S, D로 이동합니다'
                ]
            },
            {
                map: [
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00'],
                    ['00', '00', '00', '--', '--', '--', '--', '00', '00', '00'],
                    ['00', '00', '00', '--', '00', '00', '00', '00', '00', '00'],
                    ['00', '1P', '--', '--', '2W', '--', '--', '--', '2F', '00'],
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00']
                ],
                tooltip: [
                    '모든 규칙은 왼쪽부터 적용됩니다.',
                    '"SPACE"키로 물체를 부술 수 있습니다.'
                ]
            },
            {
                map: [
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00'],
                    ['00', '3F', '--', '--', '--', '--', '--', '--', '1P', '00'],
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00']
                ],
                tooltip: [
                    '모든 규칙은 왼쪽부터 적용됩니다.',
                    '"TAP"키로 물체의 색을 바꿀 수 있습니다.',
                    '바뀌는 순서는 초록 > 노랑 > 빨강 순서입니다.'
                ]
            },
            {
                map: [
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00', '00', '00'],
                    ['00', '00', '00', '00', '00', '00', '3B', '00', '00', '00', '00', '00'],
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00', '00', '00'],
                    ['00', '1P', '--', '--', '--', '--', '--', '--', '--', '--', '2F', '00'],
                    ['00', '00', '--', '00', '00', '00', '00', '00', '00', '00', '--', '00'],
                    ['00', '00', '--', '--', '--', '--', '--', '--', '--', '--', '--', '00'],
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00', '00', '00']
                ],
                tooltip: [
                    '빨간색 물체는 당신을 공격하는 적입니다.'
                ]
            },
            {
                map: [
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00', '00'],
                    ['00', '4W', '--', '--', '--', '00', '00', '00', '00', '00', '00'],
                    ['00', '00', '00', '00', '--', '00', '00', '00', '00', '00', '00'],
                    ['00', '00', '3P', '--', '--', '--', '--', '00', '00', '00', '00'],
                    ['00', '00', '00', '00', '00', '00', '--', '00', '00', '00', '00'],
                    ['00', '00', '00', '1A', '--', '--', '--', '--', '--', '2F', '00'],
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00', '00']
                ],
                tooltip: [
                    '예외로 파란색 물체는 어떠한 규칙도 통하지 않습니다.',
                    '게다가 이들이 가장 왼쪽에 있으면 다른 물체들도 규칙을 물려받을 수 없게 됩니다.',
                    ' ',
                    '마우스 좌클릭으로 물체를 부술 수 있습니다. (공격 가능 물체만)',
                    '마우스 좌클릭으로 어떤 물체를 조작할지 선택할 수 있습니다.'
                ]
            },
            {
                map: [
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00'],
                    ['00', '--', '--', '--', '--', '--', '--', '--', '--', '00'],
                    ['00', '--', '00', '00', '00', '00', '00', '00', '--', '00'],
                    ['00', '--', '00', '00', '00', '00', '00', '00', '--', '00'],
                    ['00', '--', '--', '2F', '00', '00', '1P', '--', '--', '00'],
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00']
                ],
                tooltip: [
                    'insert tooltip here', '(8, 2)2W 이동 로직 만들고 나면 넣기.'
                ]
            },
            {
                map: [
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00'],
                    ['00', '00', '3B', '00', '3B', '00', '3B', '00', '00', '00'],
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00'],
                    ['00', '--', '--', '--', '--', '--', '--', '--', '2F', '00'],
                    ['00', '--', '00', '00', '00', '00', '00', '00', '00', '00'],
                    ['00', '--', '--', '--', '--', '--', '--', '--', '--', '00'],
                    ['00', '00', '00', '00', '00', '00', '00', '00', '--', '00'],
                    ['00', '1P', '--', '--', '--', '--', '--', '--', '--', '00'],
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00']
                ],
                tooltip: [
                    'insert tooltip here'
                ]
            },
            {
                map: [
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00'],
                    ['00', '00', '00', '3A', '2W', '--', '00', '00', '00', '00'],
                    ['00', '00', '00', '00', '00', '--', '00', '00', '00', '00'],
                    ['00', '1P', '--', '--', '--', '2W', '--', '--', '2F', '00'],
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00']
                ],
                tooltip: [
                    'insert tooltip here'
                ]
            },
            {
                map: [
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00'],
                    ['00', '00', '--', '--', '--', '--', '--', '--', '--', '00'],
                    ['00', '00', '--', '00', '00', '00', '00', '00', '--', '00'],
                    ['00', '00', '--', '--', '--', '--', '3F', '00', '3A', '00'],
                    ['00', '00', '00', '00', '00', '00', '--', '00', '00', '00'],
                    ['00', '--', '--', '--', '--', '1P', '--', '--', '--', '00'],
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00']
                ],
                tooltip: [
                    'insert tooltip here', '(5,3) 4W, 3A의 어그로 이동 로직 만들고 나면 넣기'
                ]
            },
            {
                map: [
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00'],
                    ['00', '--', '--', '--', '--', '--', '--', '00', '2F', '00'],
                    ['00', '--', '00', '00', '00', '00', '00', '4W', '--', '00'],
                    ['00', '--', '00', '--', '--', '--', '00', '--', '00', '00'],
                    ['00', '--', '00', '--', '00', '00', '4W', '--', '00', '00'],
                    ['00', '2A', '00', '2A', '00', '00', '3P', '00', '00', '00'],
                    ['00', '00', '00', '00', '00', '00', '00', '00', '00', '00']
                ],
                tooltip: [
                    'insert tooltip here'
                ]
            }
        ];

        // --- 게임 상태 변수 ---
        let currentStage = 0;
        let turnCount = 0;
        let nextObjectId = 1;
        let gameState = {
            selected: null,
            objects: [],
            history: [],
            tooltipOverride: null
        };
        let gameOver = false;
        const grid = document.getElementById('grid');
        const message = document.getElementById('message');
        const tooltip = document.getElementById('tooltip');
        const stageDisplay = document.getElementById('stage-display');
        const clearMessage = document.getElementById('clear-message');
        const MAX_HISTORY = 512;

        // --- A* 경로탐색 알고리즘 ---
        function findPathAStar(startRow, startCol, targetRow, targetCol, mapData, alliedColors) {
            const rows = mapData.length;
            const cols = mapData[0].length;
            
            function heuristic(row, col) {
                return Math.abs(row - targetRow) + Math.abs(col - targetCol);
            }
            
            function isValidMove(row, col) {
                if (row < 0 || row >= rows || col < 0 || col >= cols) return false;
                if (mapData[row][col] === '00') return false;
                
                const obj = gameState.objects.find(o => o.row === row && o.col === col);
                if (obj) {
                    if (row === targetRow && col === targetCol) return true;
                    return alliedColors.includes(obj.color);
                }
                return true;
            }
            
            const openSet = [{ row: startRow, col: startCol, g: 0, h: heuristic(startRow, startCol), f: heuristic(startRow, startCol), parent: null }];
            const closedSet = new Set();
            
            while (openSet.length > 0) {
                openSet.sort((a, b) => a.f - b.f);
                const current = openSet.shift();
                const key = `${current.row},${current.col}`;
                
                if (closedSet.has(key)) continue;
                closedSet.add(key);
                
                if (current.row === targetRow && current.col === targetCol) {
                    const path = [];
                    let node = current;
                    while (node) {
                        path.unshift({ row: node.row, col: node.col });
                        node = node.parent;
                    }
                    return path;
                }
                
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                for (const [dr, dc] of directions) {
                    const newRow = current.row + dr;
                    const newCol = current.col + dc;
                    const newKey = `${newRow},${newCol}`;
                    
                    if (closedSet.has(newKey) || !isValidMove(newRow, newCol)) continue;
                    
                    const g = current.g + 1;
                    const h = heuristic(newRow, newCol);
                    const f = g + h;
                    
                    const existing = openSet.find(node => node.row === newRow && node.col === newCol);
                    if (!existing || g < existing.g) {
                        if (existing) {
                            existing.g = g;
                            existing.f = f;
                            existing.parent = current;
                        } else {
                            openSet.push({ row: newRow, col: newCol, g, h, f, parent: current });
                        }
                    }
                }
            }
            return null;
        }

        // --- 공격 이펙트 생성 ---
        function createAttackEffect(targetRow, targetCol, attackType, attackerColor = 'red') {
            const gameContainer = document.getElementById('game-container');
            const tile = grid.querySelector(`.tile[data-row='${targetRow}'][data-col='${targetCol}']`);
            if (!tile || !gameContainer) return;

            const tileRect = tile.getBoundingClientRect();
            const containerRect = gameContainer.getBoundingClientRect();

            const effectElement = document.createElement('div');
            const colorSuffix = attackerColor === 'blue' ? '-blue' : '';
            effectElement.className = attackType === 'near' ? `attack-effect${colorSuffix}-near` : `attack-effect${colorSuffix}-far`;
            
            effectElement.style.position = 'absolute';
            effectElement.style.left = `${tileRect.left - containerRect.left}px`;
            effectElement.style.top = `${tileRect.top - containerRect.top}px`;
            
            if (attackType === 'near') {
                effectElement.style.width = `${tileRect.width * 2}px`;
                effectElement.style.height = `${tileRect.height * 2}px`;
                effectElement.style.transform = 'translate(-25%, -25%)';
            } else {
                effectElement.style.width = `${tileRect.width}px`;
                effectElement.style.height = `${tileRect.height / 4}px`;
                effectElement.style.top = `${tileRect.top - containerRect.top + tileRect.height * 0.375}px`;
            }
            
            gameContainer.appendChild(effectElement);

            setTimeout(() => {
                if (effectElement.parentNode) effectElement.remove();
            }, attackType === 'near' ? 1500 : 300);
        }

        // --- AI 시스템 ---
        function processEnemyNearRange(obj) {
            let currentTarget = gameState.objects.find(o => o.id === obj.targetId);

            // 인식 해제 조건 확인
            if (currentTarget && (!isObjectPresent(currentTarget) || currentTarget.color !== 'green')) {
                obj.targetId = null;
                currentTarget = null;
                obj.isTracking = false;
            }

            // 새로운 타겟 탐색
            if (!obj.targetId) {
                const greenObjs = gameState.objects.filter(g =>
                    g.color === 'green' &&
                    Math.abs(g.row - obj.row) <= 2 && // 5x5 인식 범위
                    Math.abs(g.col - obj.col) <= 2
                );

                if (greenObjs.length > 0) {
                    greenObjs.sort((a, b) => {
                        const distA = Math.abs(a.row - obj.row) + Math.abs(a.col - obj.col);
                        const distB = Math.abs(b.row - obj.row) + Math.abs(b.col - obj.col);
                        if (distA !== distB) return distA - distB;
                        if (a.col !== b.col) return a.col - b.col;
                        return a.row - b.row;
                    });
                    obj.targetId = greenObjs[0].id;
                    currentTarget = greenObjs[0];
                    obj.isTracking = true;
                    addHistory('aiTargetChange', { objId: obj.id, targetId: obj.targetId });
                } else {
                    obj.isTracking = false;
                    return;
                }
            }

            // 타겟 확정 후 처리
            if (obj.isTracking && currentTarget) {
                // 공격 범위 확인 및 공격
                if (Math.abs(currentTarget.row - obj.row) <= 1 && Math.abs(currentTarget.col - obj.col) <= 1) {
                    addHistory('attack', { attacker: { id: obj.id, type: obj.type }, target: { ...currentTarget } });
                    gameState.objects = gameState.objects.filter(o => o.id !== currentTarget.id);
                    createAttackEffect(currentTarget.row, currentTarget.col, 'near', obj.color);
                    obj.targetId = null;
                    obj.isTracking = false;
                    
                    if (currentTarget === gameState.selected) gameState.selected = null;
                    if (currentTarget.type === 'P' && currentTarget.color === 'green') {
                        gameOver = true;
                        gameState.tooltipOverride = 'R을 눌러 스테이지 재시작';
                    }
                    return;
                }

                // 이동 (원래 동맹 관계)
                let alliedColors = obj.color === 'red' ? ['red', 'yellow', 'blue'] : ['blue', 'yellow'];
                const path = findPathAStar(obj.row, obj.col, currentTarget.row, currentTarget.col, stages[currentStage].map, alliedColors);

                if (path && path.length > 1) {
                    addHistory('enemyMove', { objId: obj.id, oldRow: obj.row, oldCol: obj.col, newRow: path[1].row, newCol: path[1].col });
                    
                    // 이동 방향 계산 및 스프라이트 업데이트
                    const deltaRow = path[1].row - obj.row;
                    const deltaCol = path[1].col - obj.col;
                    let direction = 'B'; // 기본값
                    if (deltaRow < 0) direction = 'T';
                    else if (deltaRow > 0) direction = 'B';
                    else if (deltaCol < 0) direction = 'L';
                    else if (deltaCol > 0) direction = 'R';
                    
                    obj.row = path[1].row;
                    obj.col = path[1].col;
                    updateSprite(obj, 'move', direction);
                }
            }
        }

        function processEnemyLongRange(obj) {
            let currentTarget = gameState.objects.find(o => o.id === obj.targetId);

            // 인식 해제 조건 확인
            if (currentTarget && (!isObjectPresent(currentTarget) || currentTarget.color !== 'green')) {
                obj.targetId = null;
                currentTarget = null;
                obj.lastAttackTurn = null;
                obj.isTracking = false;
            }

            // 새로운 타겟 탐색
            if (!obj.targetId) {
                const greenObjs = gameState.objects.filter(g =>
                    g.color === 'green' &&
                    Math.abs(g.row - obj.row) <= 3 && // 7x7 인식 범위
                    Math.abs(g.col - obj.col) <= 3
                );

                if (greenObjs.length > 0) {
                    greenObjs.sort((a, b) => {
                        const distA = Math.abs(a.row - obj.row) + Math.abs(a.col - obj.col);
                        const distB = Math.abs(b.row - obj.row) + Math.abs(b.col - obj.col);
                        if (distA !== distB) return distA - distB;
                        if (a.col !== b.col) return a.col - b.col;
                        return a.row - b.row;
                    });
                    obj.targetId = greenObjs[0].id;
                    currentTarget = greenObjs[0];
                    obj.lastAttackTurn = turnCount;
                    obj.isTracking = true;
                    
                    // 타겟 방향으로 스프라이트 업데이트
                    const deltaRow = currentTarget.row - obj.row;
                    const deltaCol = currentTarget.col - obj.col;
                    let direction = 'B';
                    if (Math.abs(deltaRow) > Math.abs(deltaCol)) {
                        direction = deltaRow < 0 ? 'T' : 'B';
                    } else {
                        direction = deltaCol < 0 ? 'L' : 'R';
                    }
                    updateSprite(obj, 'aim', direction);
                    
                    addHistory('aiTargetChange', { objId: obj.id, targetId: obj.targetId });
                } else {
                    obj.isTracking = false;
                    return;
                }
            }

            // 타겟 확정 후 공격
            if (obj.isTracking && currentTarget) {
                if (Math.abs(currentTarget.row - obj.row) <= 3 && Math.abs(currentTarget.col - obj.col) <= 3) {
                    if ((turnCount - obj.lastAttackTurn) >= 2) {
                        addHistory('attack', { attacker: { id: obj.id, type: obj.type }, target: { ...currentTarget } });
                        gameState.objects = gameState.objects.filter(o => o.id !== currentTarget.id);
                        createAttackEffect(currentTarget.row, currentTarget.col, 'far', obj.color);
                        obj.targetId = null;
                        obj.lastAttackTurn = null;
                        obj.isTracking = false;
                        
                        if (currentTarget === gameState.selected) gameState.selected = null;
                        if (currentTarget.type === 'P' && currentTarget.color === 'green') {
                            gameOver = true;
                            gameState.tooltipOverride = 'R을 눌러 스테이지 재시작';
                        }
                    }
                }
            }
        }

        function isObjectPresent(obj) {
            return gameState.objects.some(o => o.id === obj.id);
        }

        // --- 게임 로직 함수 ---
        function loadStage() {
            const stage = stages[currentStage];
            gameState.objects = [];
            nextObjectId = 1;
            
            for (let row = 0; row < stage.map.length; row++) {
                for (let col = 0; col < stage.map[0].length; col++) {
                    const code = stage.map[row][col];
                    if (code !== '00' && code !== '--') {
                        const type = code.slice(1);
                        const color = code[0] === '1' ? 'green' : code[0] === '2' ? 'yellow' : code[0] === '3' ? 'red' : 'blue';
                        gameState.objects.push({ 
                            id: nextObjectId++,
                            row, 
                            col, 
                            type, 
                            color,
                            targetId: null,
                            isTracking: false,
                            lastAttackTurn: null,
                            spriteState: 'a',
                            direction: 'B'
                        });
                    }
                }
            }
            
            gameState.selected = gameState.objects.find(o => o.type === 'P' && o.color === 'green');
            turnCount = 0;
            gameOver = false;
            gameState.history = [];
            gameState.tooltipOverride = null;
            console.log(`Turn: ${turnCount}`);
            renderMap();
        }

        function renderMap() {
            const stage = stages[currentStage];
            grid.style.gridTemplateColumns = `repeat(${stage.map[0].length}, calc(40px * 1.25))`;
            grid.style.gridTemplateRows = `repeat(${stage.map.length}, calc(40px * 1.25))`;
            grid.innerHTML = '';

            for (let row = 0; row < stage.map.length; row++) {
                for (let col = 0; col < stage.map[0].length; col++) {
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    tile.classList.add(stage.map[row][col] === '00' ? 'empty' : 'floor');

                    const obj = gameState.objects.find(o => o.row === row && o.col === col);
                    if (obj) {
                        const objCode = `${obj.color === 'green' ? '1' : obj.color === 'yellow' ? '2' : obj.color === 'red' ? '3' : '4'}${obj.type}`;
                        
                        // 스프라이트 애니메이션 지원 (수정됨)
                        let imageKey = objCode;
                        if (['P', 'A', 'B'].includes(obj.type)) {
                            imageKey = `${objCode}_${obj.spriteState}${obj.direction}`;
                        }
                        
                        if (objectImages[imageKey]) {
                            const img = document.createElement('img');
                            img.src = objectImages[imageKey];
                            img.alt = obj.type;
                            img.onerror = () => {
                                tile.classList.add(obj.color);
                                tile.textContent = obj.type;
                            };
                            tile.appendChild(img);
                        } else {
                            tile.classList.add(obj.color);
                            tile.textContent = obj.type;
                        }
                        
                        // 추적 중인 AI 시각화
                        if (obj.isTracking && (obj.type === 'A' || obj.type === 'B') && (obj.color === 'red' || obj.color === 'blue')) {
                            tile.classList.add('tracking');
                        }
                        
                        if (gameState.selected && gameState.selected.id === obj.id) {
                            tile.style.border = '2px solid #fff';
                        }
                    }
                    
                    tile.dataset.row = row;
                    tile.dataset.col = col;
                    grid.appendChild(tile);
                }
            }
            
            message.textContent = gameOver ? 'Z: 한 칸 되돌리기, R: 스테이지 초기화 하기' : '';
            stageDisplay.textContent = `Stage: ${currentStage + 1}`;
            const tooltipText = gameState.tooltipOverride ? [gameState.tooltipOverride] : stage.tooltip;
            tooltip.innerHTML = tooltipText.map(line => `<p>${line}</p>`).join('');
        }

        function canMove(row, col, movingObj) {
            const stage = stages[currentStage];
            if (row < 0 || row >= stage.map.length || col < 0 || col >= stage.map[0].length || stage.map[row][col] === '00') {
                return false;
            }
            const obj = gameState.objects.find(o => o.row === row && o.col === col);
            if (obj) {
                return obj.type === 'F' && obj.color === 'yellow' && movingObj.type === 'P' && movingObj.color === 'green';
            }
            return true;
        }

        function addHistory(action, data) {
            const relevantAiStates = gameState.objects
                .filter(o => ['A', 'B'].includes(o.type) && ['red', 'blue'].includes(o.color))
                .map(o => ({
                    id: o.id,
                    isTracking: o.isTracking,
                    targetId: o.targetId,
                    lastAttackTurn: o.lastAttackTurn
                }));

            gameState.history.push({
                action,
                data,
                state: {
                    objects: JSON.parse(JSON.stringify(gameState.objects)),
                    aiStates: relevantAiStates,
                    turnCount: turnCount,
                    currentSelectedObjectId: gameState.selected ? gameState.selected.id : null
                }
            });
            
            if (gameState.history.length > MAX_HISTORY) {
                gameState.history.shift();
            }
        }

        function advanceTurn() {
            if (gameOver) return;
            turnCount++;
            console.log(`Turn: ${turnCount}`);

            // AI 처리
            gameState.objects.forEach(obj => {
                if ((obj.type === 'A') && (obj.color === 'red' || obj.color === 'blue')) {
                    processEnemyNearRange(obj);
                } else if ((obj.type === 'B') && (obj.color === 'red' || obj.color === 'blue')) {
                    processEnemyLongRange(obj);
                }
            });

            // 기존 3B 공격 로직 (호환성 유지)
            gameState.objects.forEach(obj => {
                if (obj.color === 'red' && obj.type === 'B' && !obj.hasOwnProperty('targetId')) {
                    const range = 3;
                    const greenObjs = gameState.objects.filter(o => o.color === 'green');
                    greenObjs.forEach(green => {
                        if (Math.abs(green.row - obj.row) <= range && Math.abs(green.col - obj.col) <= range) {
                            obj.moving = true;
                            if (turnCount % 2 === 0) {
                                const tile = grid.querySelector(`.tile[data-row="${green.row}"][data-col="${green.col}"]`);
                                if (tile) {
                                    tile.classList.add('attack-effect');
                                    setTimeout(() => tile.classList.remove('attack-effect'), 500);
                                }
                                addHistory('attack', { target: { ...green } });
                                gameState.objects = gameState.objects.filter(o => o.id !== green.id);
                                if (green === gameState.selected) gameState.selected = null;
                                gameOver = true;
                            }
                        } else {
                            obj.moving = false;
                        }
                    });
                }
            });

            renderMap();
        }

        function findLeftmost() {
            let leftmost = null;
            gameState.objects.forEach(obj => {
                if (!leftmost || obj.col < leftmost.col || (obj.col === leftmost.col && obj.row < leftmost.row)) {
                    leftmost = obj;
                }
            });
            return leftmost;
        }

        function updateSprite(obj, action, direction) {
            // 스프라이트 애니메이션 지원 확장 (수정됨)
            if (!['P', 'A', 'B'].includes(obj.type)) return;
            
            if (direction) {
                const dirMap = { 'w': 'T', 's': 'B', 'a': 'L', 'd': 'R', 'T': 'T', 'B': 'B', 'L': 'L', 'R': 'R' };
                obj.direction = dirMap[direction] || obj.direction;
            }
            
            if (action === 'move' || action === 'aim') {
                obj.spriteState = obj.spriteState === 'a' ? 'b' : 'a';
            }
        }

        // --- 이벤트 리스너 ---
        document.addEventListener('keydown', (e) => {
            // BGM 재생
            if (bgmLoaded && bgm.paused) {
                console.log('Attempting to play BGM on keydown');
                bgm.play().then(() => console.log('BGM 재생 시작:', bgmUrl))
                    .catch(err => console.warn('BGM 재생 실패:', err));
            }

            if (gameOver && e.key !== 'z' && e.key !== 'r') return;
            let actionTaken = false;

            // 이동 (WASD)
            if (e.key === 'w' || e.key === 's' || e.key === 'a' || e.key === 'd') {
                if (!gameState.selected || gameState.selected.color !== 'green' || gameState.selected.type === 'F') return;
                const newPos = { row: gameState.selected.row, col: gameState.selected.col };
                if (e.key === 'w') newPos.row--;
                else if (e.key === 's') newPos.row++;
                else if (e.key === 'a') newPos.col--;
                else if (e.key === 'd') newPos.col++;
                
                if (canMove(newPos.row, newPos.col, gameState.selected)) {
                    addHistory('move', {
                        obj: gameState.selected,
                        oldRow: gameState.selected.row,
                        oldCol: gameState.selected.col
                    });
                    gameState.selected.row = newPos.row;
                    gameState.selected.col = newPos.col;
                    updateSprite(gameState.selected, 'move', e.key);
                    actionTaken = true;
                    
                    // 클리어 조건 체크
                    if (gameState.selected.type === 'P' && gameState.objects.some(o => o.row === newPos.row && o.col === newPos.col && o.type === 'F' && o.color === 'yellow')) {
                        currentStage++;
                        if (currentStage >= stages.length) currentStage = 0;
                        clearMessage.style.display = 'block';
                        clearMessage.classList.add('fade-in-out');
                        setTimeout(() => {
                            clearMessage.style.display = 'none';
                            clearMessage.classList.remove('fade-in-out');
                        }, 2000);
                        loadStage();
                        return;
                    }
                }
            }
            // 제거 (Space)
            else if (e.key === ' ') {
                const leftmost = findLeftmost();
                if (leftmost && leftmost.color === 'blue') {
                    message.textContent = '파란색 물체로 인해 규칙이 막혔습니다';
                    setTimeout(() => message.textContent = '', 3000);
                    return;
                }
                if (leftmost) {
                    addHistory('remove', { obj: { ...leftmost } });
                    gameState.objects = gameState.objects.filter(o => o.id !== leftmost.id);
                    if (leftmost === gameState.selected) {
                        gameState.selected = gameState.objects.find(o => o.color === 'green' && o.type !== 'F') || null;
                    }
                    if (leftmost.type === 'F' && leftmost.color === 'yellow') {
                        gameState.tooltipOverride = 'R을 눌러 스테이지 재시작';
                        gameOver = true;
                    } else if (currentStage === 1 && leftmost.type === 'P' && leftmost.color === 'green') {
                        gameState.tooltipOverride = 'R을 눌러 스테이지 재시작';
                        gameOver = true;
                    }
                }
                actionTaken = true;
                renderMap();
            }
            // 색상 변경 (Tab)
            else if (e.key === 'Tab') {
                e.preventDefault();
                const leftmost = findLeftmost();
                if (leftmost && leftmost.color === 'blue') {
                    message.textContent = '파란색 물체로 인해 규칙이 막혔습니다';
                    setTimeout(() => message.textContent = '', 3000);
                    return;
                }
                if (leftmost) {
                    const colors = ['green', 'yellow', 'red'];
                    const currentIndex = colors.indexOf(leftmost.color);
                    addHistory('color', { obj: leftmost, oldColor: leftmost.color });
                    leftmost.color = colors[(currentIndex + 1) % 3];
                }
                actionTaken = true;
            }
            // 턴 넘기기 (Q)
            else if (e.key === 'q') {
                addHistory('skip', { turn: turnCount });
                actionTaken = true;
            }
            // 리셋 (R)
            else if (e.key === 'r') {
                loadStage();
                return;
            }
            // 되돌리기 (Z)
            else if (e.key === 'z' && gameState.history.length > 0) {
                const lastStateSnapshot = gameState.history.pop().state;

                gameState.objects = JSON.parse(JSON.stringify(lastStateSnapshot.objects));
                lastStateSnapshot.aiStates.forEach(savedAiState => {
                    const gameObj = gameState.objects.find(o => o.id === savedAiState.id);
                    if (gameObj) {
                        gameObj.isTracking = savedAiState.isTracking;
                        gameObj.targetId = savedAiState.targetId;
                        gameObj.lastAttackTurn = savedAiState.lastAttackTurn;
                    }
                });

                turnCount = lastStateSnapshot.turnCount;
                gameState.selected = lastStateSnapshot.currentSelectedObjectId
                    ? gameState.objects.find(o => o.id === lastStateSnapshot.currentSelectedObjectId)
                    : null;
                gameOver = false;
                gameState.tooltipOverride = null;

                console.log(`Turn: ${turnCount}`);
                renderMap();
                return;
            }

            if (actionTaken) advanceTurn();
        });

        // 마우스 좌클릭 처리
        grid.addEventListener('click', (e) => {
            if (gameOver) return;
            const tile = e.target.closest('.tile');
            if (!tile) return;
            const row = parseInt(tile.dataset.row);
            const col = parseInt(tile.dataset.col);
            const clickedObj = gameState.objects.find(o => o.row === row && o.col === col);

            // 초록색 오브젝트 선택
            if (clickedObj && clickedObj.color === 'green' && clickedObj.type !== 'F') {
                gameState.selected = clickedObj;
                renderMap();
                return;
            }

            // 공격 처리
            const greenAttack = gameState.selected && gameState.selected.color === 'green' && (gameState.selected.type === 'A' || gameState.selected.type === 'B');
            if (greenAttack) {
                const range = gameState.selected.type === 'A' ? 1 : 3;
                if (Math.abs(row - gameState.selected.row) <= range && Math.abs(col - gameState.selected.col) <= range) {
                    const target = gameState.objects.find(o => o.row === row && o.col === col && o.type !== 'I' && o.type !== 'F');
                    if (target) {
                        addHistory('attack', { target: { ...target } });
                        gameState.objects = gameState.objects.filter(o => o.id !== target.id);
                        createAttackEffect(row, col, gameState.selected.type === 'A' ? 'near' : 'far', 'green');
                        
                        if (target === gameState.selected) gameState.selected = null;
                        if (currentStage === 1 && target.type === 'P' && target.color === 'green') {
                            gameState.tooltipOverride = 'R을 눌러 스테이지 재시작';
                            gameOver = true;
                        }
                    }
                    gameState.tooltipOverride = null;
                    advanceTurn();
                }
            }
        });

        // 게임 시작
        loadStage();
    </script>
</body>
</html>
